课堂练习代码以及其产生的现象总结：

质心
void Start () {
    rigid = GetComponent<Rigidbody>();
    // 设置centerOfMass，指定重心
    rigid.centerOfMass = new Vector3(0, -1, 0);
}

鼠标射线检测
   // 射线与指定层碰撞
   if (Input.GetKeyDown(KeyCode.R))
   {
       RaycastHit[] allHitInfo; // 保存碰撞信息

       Ray ray = new Ray(Vector3.zero, Vector3.forward);
       //LayerMask控制射线可以和层发生碰撞
       //LayerMask是一个整形，32bit，32个层，整形的每一位代表一层
       allHitInfo = Physics.RaycastAll(ray, 10.0f, layerMask);
       // 绘制出射线
       Debug.DrawRay(Vector3.zero, Vector3.forward * 10, Color.red, 2);

       for (int i = 0; i < allHitInfo.Length; ++i)
       {
           Debug.Log(i + " : " + allHitInfo[i].collider.gameObject.name);
           Debug.Log(i + " 碰撞点: " + allHitInfo[i].point.ToString());
           Debug.Log(i + " 碰撞点法线向量: " + allHitInfo[i].normal.ToString());
       }

   }
   Ray mouseRay = Camera.main.ScreenPointToRay(Input.mousePosition);
RaycastHit hitInfo;
if (Input.GetMouseButtonDown(0) && Physics.Raycast(mouseRay, out hitInfo, 50))
{
    Debug.Log("Click " + hitInfo.collider.gameObject.name);
    // 绘制点击点
    Debug.DrawRay(hitInfo.point, hitInfo.normal * 5, Color.green, 20, false);
}

施加力的方式
   // 施加的力高于重心
    if(Input.GetKeyDown(KeyCode.H))
    {
        rigid.AddForceAtPosition(new Vector3(0, 0, -10), new Vector3(0.5f, 1.5f, 0.5f));
    }
   // 施加的力等于重心
   if(Input.GetKeyDown(KeyCode.E))
   {
        rigid.AddForceAtPosition(new Vector3(-10, 0, 0), new Vector3(0.5f, 1f, 0.5f));
   }
    // 施加的力低于重心
   if(Input.GetKeyDown(KeyCode.L))
   {
        rigid.AddForceAtPosition(new Vector3(0, 0, -10), new Vector3(0.5f, 0.5f, 0.5f));
   }
   // 让小球旋转
    if(Input.GetKeyDown(KeyCode.R))
    {
       rigid.angularVelocity = new Vector3(0, 60, 0);
    }
   
屏幕坐标与视图坐标、世界坐标的转换
   // 按下鼠标左键
   if (Input.GetMouseButtonDown(0))
   {
       // 鼠标指针位置是屏幕坐标系
       Vector2 mousePos = Input.mousePosition;
       Debug.Log("鼠标指针在屏幕上的位置：" + mousePos);

       // 将鼠标指针位置转化为视图坐标系时，需要利用摄像机计算
       Vector3 viewPoint = UnityEngine.Camera.main.ScreenToViewportPoint(Input.mousePosition);
       Debug.Log("鼠标指针位置的视图坐标为：" + viewPoint);

       // 将鼠标指针位置转化为世界坐标系时，需要利用摄像机计算
       Vector3 worldPoint = UnityEngine.Camera.main.ScreenToWorldPoint(Input.mousePosition);
       Debug.Log("鼠标指针位置的世界坐标为：" + worldPoint);
   }
} }

静态碰撞体：
不能动的，否则会出现问题

刚体碰撞体：
只受物理系统的控制，不建议通过随意控制

运动学的刚体碰撞体：
运动可以摆脱物理系统，由随意控制，碰撞还是由物理系统来控制

触发器和碰撞体：
触发器不会发生碰撞，是会穿过物体，碰撞体才会发生碰撞

物理关节：
限制一类运动的自由度，允许另外一类运动的自由度

射线检测：
通过将物体设置在不同的层，然后在脚本中为射线设置能检测的层的物体

控制物体运动的方法：
直接操作坐标，使用物理引擎操作，使用角色控制器

考考你
发生碰撞的必要条件有哪些？
参与碰撞的物体都必须添加碰撞器(Collider)组件
其中一个物体还必须添加刚体组件(Rigidbody)

帮帮我
当检查两个物体发生碰撞时，如何让运动的物体停止运动？
