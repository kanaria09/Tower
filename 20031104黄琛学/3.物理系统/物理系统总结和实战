课堂练习代码以及其产生的现象总结 using UnityEngine; public class Player : MonoBehaviour { Rigidbody rigid; int layerMask; // Start is called before the first frame update void Start() { rigid = GetComponent(); Debug.Log(rigid.gameObject.name); layerMask = LayerMask.GetMask("Water", "Player", "wape", "enemy"); // 设置重心 rigid.centerOfMass = new Vector3(0.5f, 1, 0.5f); Debug.Log("Center of Mass : " + rigid.centerOfMass.ToString()); } //private void FixedUpdate() //{ //Debug.Log("FixedUpdate delta time : " + Time.fixedDeltaTime);

// Update is called once per frame
void Update() { //Debug.Log("Update delta time : " + Time.deltaTime);

   // 施加力使物体跳跃
   if (Input.GetButtonDown("Jump"))
   {
       rigid.velocity = new Vector3(rigid.velocity.x, 0, rigid.velocity.z);
       rigid.AddForce(new Vector3(0, 100, 0));
   }
   
   // 射线与指定层碰撞
   if (Input.GetKeyDown(KeyCode.R))
   {
       RaycastHit[] allHitInfo; // 保存碰撞信息

       Ray ray = new Ray(Vector3.zero, Vector3.forward);
       //LayerMask控制射线可以和层发生碰撞
       //LayerMask是一个整形，32bit，32个层，整形的每一位代表一层
       allHitInfo = Physics.RaycastAll(ray, 10.0f, layerMask);
       // 绘制出射线
       Debug.DrawRay(Vector3.zero, Vector3.forward * 10, Color.red, 2);

       for (int i = 0; i < allHitInfo.Length; ++i)
       {
           Debug.Log(i + " : " + allHitInfo[i].collider.gameObject.name);
           Debug.Log(i + " 碰撞点: " + allHitInfo[i].point.ToString());
           Debug.Log(i + " 碰撞点法线向量: " + allHitInfo[i].normal.ToString());
       }

   }
   // 施加的力高于重心
    if(Input.GetKeyDown(KeyCode.H))
    {
        rigid.AddForceAtPosition(new Vector3(0, 0, -10), new Vector3(0.5f, 1.5f, 0.5f));
    }
   // 施加的力等于重心
   if(Input.GetKeyDown(KeyCode.E))
   {
        rigid.AddForceAtPosition(new Vector3(-10, 0, 0), new Vector3(0.5f, 1f, 0.5f));
   }

    // 施加的力低于重心
   if(Input.GetKeyDown(KeyCode.L))
   {
        rigid.AddForceAtPosition(new Vector3(0, 0, -10), new Vector3(0.5f, 0.5f, 0.5f));
   }
   // 让小球旋转
    if(Input.GetKeyDown(KeyCode.R))
    {
       rigid.angularVelocity = new Vector3(0, 60, 0);
    }
   
   //检查鼠标点击的物体
   Ray mouseRay = Camera.main.ScreenPointToRay(Input.mousePosition);
   RaycastHit hitInfo;

   //鼠标左键被按下
   if (Input.GetMouseButtonDown(0) && Physics.Raycast(mouseRay, out hitInfo, 50))
   {
       Debug.Log("Click " + hitInfo.collider.gameObject.name);
       // 绘制点击点
       Debug.DrawRay(hitInfo.point, hitInfo.normal * 5, Color.green, 2, false);
   }
   // 按下鼠标左键
   if (Input.GetMouseButtonDown(0))
   {
       // 鼠标指针位置是屏幕坐标系
       Vector2 mousePos = Input.mousePosition;
       Debug.Log("鼠标指针在屏幕上的位置：" + mousePos);

       // 将鼠标指针位置转化为视图坐标系时，需要利用摄像机计算
       Vector3 viewPoint = UnityEngine.Camera.main.ScreenToViewportPoint(Input.mousePosition);
       Debug.Log("鼠标指针位置的视图坐标为：" + viewPoint);

       // 将鼠标指针位置转化为世界坐标系时，需要利用摄像机计算
       Vector3 worldPoint = UnityEngine.Camera.main.ScreenToWorldPoint(Input.mousePosition);
       Debug.Log("鼠标指针位置的世界坐标为：" + worldPoint);
   }
} }

静态碰撞体：
不能动的，否则会出现问题
刚体碰撞体：
只受物理系统的控制，不建议通过随意控制
运动学的刚体碰撞体：
运动可以摆脱物理系统，由随意控制，碰撞还是由物理系统来控制
触发器和碰撞体：
触发器不会发生碰撞，是会穿过物体，碰撞体才会发生碰撞
物理关节：
限制一类运动的自由度，允许另外一类运动的自由度
射线检测：
通过将物体设置在不同的层，然后在脚本中为射线设置能检测的层的物体
控制物体运动的方法：
直接操作坐标，使用物理引擎操作，使用角色控制器
物理系统的编程:
获取刚体
修改速度
施加力
层与射线
修改物理材质
FixedUpdate
修改角速度
质心
刚体约束